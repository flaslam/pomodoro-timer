import type { NextPage } from "next";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { useEffect, useRef, useState } from "react";
import { formatSecondsToMinutes } from "../lib/utils";
import { OptionsButton, TimerButton } from "../components/buttons";
import Nav from "../components/Nav";
import { Period, Timer, timers } from "../lib/timers";
import { Stats } from "../lib/stats";
import { ColorScheme } from "../lib/themes";

interface HomeProps {
  theme: ColorScheme;
  setTheme(colorScheme: ColorScheme): void;
}

const Home: NextPage<HomeProps> = ({ theme, setTheme }) => {
  const STATS_DATA: string = "pomodoroStats";
  const isMounted = useRef(false);
  const [timer, setTimer] = useState<number>(timers.work.length);
  const [currentTimerType, setCurrentTimerType] = useState<Timer>(timers.work);
  const [intervalId, setIntervalId] = useState<any>(null);
  const [timerRunning, setTimerRunning] = useState<boolean>(false);
  const [sessionCount, setSessionCount] = useState<number>(1);
  const [progress, setProgress] = useState<number>(0);

  // TODO: switch stats to useContext to use in our report without drilling
  const [stats, setStats] = useState<Stats>({ focusPeriodsTotal: 0 });

  const handleTimerOptionButton = (newTimerType: Timer) => {
    // Alert user that changing the option will cancel the current timer
    if (timerRunning) {
      stopTimer();
      const result = confirm(
        "Timer is currently running. Are you sure you want to change?"
      );

      if (result) {
        updateTimerType(newTimerType);
        return;
      } else {
        startTimer();
      }
      return;
    }

    updateTimerType(newTimerType);
  };

  const startTimer = () => {
    if (timer <= 0) return;

    const interval = setInterval(() => {
      setTimer((prevCount) => prevCount - 1);
    }, 1000);

    setIntervalId(interval);
    setTimerRunning(true);
  };

  const stopTimer = () => {
    if (intervalId) {
      clearInterval(intervalId);
      setIntervalId(null);
    }
    setTimerRunning(false);
  };

  const updateTimerType = (newTimerType: Timer) => {
    if (timerRunning) stopTimer();
    setTimer(newTimerType.length);
    setCurrentTimerType(newTimerType);
    setProgress(0);
    setTheme(newTimerType.theme);
  };

  const completeInterval = () => {
    // Keep a count of sessions
    if (currentTimerType.type === Period.Work) {
      setSessionCount((prevCount) => prevCount + 1);

      updateStats();

      if (sessionCount % 4 === 0) {
        updateTimerType(timers.longBreak);
        return;
      }

      updateTimerType(timers.shortBreak);
      return;
    }

    // We are on a break
    updateTimerType(timers.work);
  };

  const loadStats = () => {
    // Load our user stats
    const user = localStorage.getItem(STATS_DATA);
    if (user) {
      const data = JSON.parse(user);
      setStats(data);
      return;
    }

    // Create a user as we have none
    localStorage.setItem(STATS_DATA, JSON.stringify(stats));
  };

  const updateStats = () => {
    setStats((prevState) => {
      const newStats: Stats = {
        focusPeriodsTotal: prevState.focusPeriodsTotal + 1,
      };
      return newStats;
    });
  };

  // On component mount
  useEffect(() => {
    loadStats();

    // Initiate timer with current timer type length
    setTimer(currentTimerType.length);

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // On component update timer
  useEffect(() => {
    if (timerRunning) {
      // Update progress bar
      setProgress(
        ((currentTimerType.length - timer) / currentTimerType.length) * 100
      );
    }

    if (timer <= 0 && timerRunning) {
      stopTimer();

      // Mark timer complete.
      completeInterval();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [timer]);

  // On component update stats
  useEffect(() => {
    // Make sure this doesn't run on first mount
    if (!isMounted.current) {
      isMounted.current = true;
      return;
    }

    // save to local storage
    localStorage.setItem(STATS_DATA, JSON.stringify(stats));
  }, [stats]);

  return (
    <div className={styles.container}>
      <Head>
        <title>Pomodoro Timer</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <style>{`
        html {
          background-color: ${theme.bg};
        }
      `}</style>

      <Nav progress={progress} theme={theme} stats={stats} />

      <main className={styles.main}>
        <div
          className={styles.timerContainer}
          style={{ backgroundColor: theme.light }}
        >
          <div className={styles.timerOptions}>
            <ul>
              <li>
                <OptionsButton
                  onClick={() => handleTimerOptionButton(timers.work)}
                  style={{
                    backgroundColor:
                      currentTimerType === timers.work
                        ? theme.dark
                        : theme.light,
                    fontWeight:
                      currentTimerType === timers.work ? 600 : undefined,
                  }}
                >
                  Pomodoro
                </OptionsButton>
              </li>
              <li>
                <OptionsButton
                  onClick={() => handleTimerOptionButton(timers.shortBreak)}
                  style={{
                    backgroundColor:
                      currentTimerType === timers.shortBreak
                        ? theme.dark
                        : theme.light,
                    fontWeight:
                      currentTimerType === timers.shortBreak ? 600 : undefined,
                  }}
                >
                  Short Break
                </OptionsButton>
              </li>
              <li>
                <OptionsButton
                  onClick={() => handleTimerOptionButton(timers.longBreak)}
                  style={{
                    backgroundColor:
                      currentTimerType === timers.longBreak
                        ? theme.dark
                        : theme.light,
                    fontWeight:
                      currentTimerType === timers.longBreak ? 600 : undefined,
                  }}
                >
                  Long Break
                </OptionsButton>
              </li>
            </ul>
          </div>
          <div className={styles.timerDisplay}>
            {formatSecondsToMinutes(timer)}
          </div>
          {!timerRunning ? (
            <TimerButton
              className={styles.timerButton}
              onClick={startTimer}
              style={{ color: theme.bg }}
            >
              Start
            </TimerButton>
          ) : (
            <TimerButton
              className={styles.timerButton}
              onClick={stopTimer}
              style={{ color: theme.bg }}
            >
              Stop
            </TimerButton>
          )}
        </div>

        <div className={styles.timerDetails}>
          <div>#{sessionCount}</div>
          <div>
            {currentTimerType.type === Period.Work ? (
              <>Time to focus!</>
            ) : (
              <>Time for a break!</>
            )}
          </div>
        </div>
        {/* {!isMounted.current ? null : (
          <div>user stats: {stats.focusPeriodsTotal}</div>
        )} */}
      </main>
    </div>
  );
};

export default Home;
